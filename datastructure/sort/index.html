<!doctype html>
<html lang="en-us">
  <head>
    <title>常见的排序算法总结 // Your title</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.62.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://qmr0925.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="常见的排序算法总结"/>
<meta name="twitter:description" content="经典排序算法的总结   之前总是听一些大牛说学会了排序就相等于学会了算法，能手写个快速排序基本就能通过面试了，这一
 点我是很不理解的；后来慢慢地发现这是有道理的，常见的几种排序算法中蕴含了许多经典的算法思想，
比如说递归、分治、迭代、双指针、空间换时间等，算法的问题很多，但是计算机处理问题的方式却只
有那一种。所以要归根溯源，从简单的排序算法中去学习算法思想也是一种很有效的方法
一、算法描述  对一个无序的数组进行排序 (从小到大或者从大到小)
 二、算法分类标准  划分排序算法的主要标准有稳定性、内外排序、时空复杂度、是否比较排序等
  1.稳定性   如果数组中有两个元素是相等的，在经过某个排序算法之后，原来前面的那个元素仍然在另一个元素的
 前面，那这个排序算法就是稳定的；相反如果在原来两个相等元素中前面的一个元素被移到了后面，那就
是不稳定的
 2.内外排序   内排序是所有的排序操作都在内存中完成；
  外排序是由于数据太大，因此把数据放入磁盘中，排序需要经过磁盘和内存的数据传输才能进行
  3.是否比较排序   比较排序： 一个算法在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个算法
 就是比较排序，常见的排序算法都是比较排序算法，比如冒泡排序、插入排序、堆排序，这些排序
算法的平均时间复杂度最快也只能是O(nlogn)
 非比较排序比较典型的算法有计数排序、桶排序和基数排序，这类排序的时间复杂度可以达到
 O(n)的级别
 4.时空复杂度   就是时间复杂度和空间的复杂度了
 三、常见的排序算法  1.冒泡排序(Bubble Sort)  （1）算法描述：冒泡排序是将相邻元素进行比较,大数慢慢地沉底，小数放置到前面
（2）算法特点：
  内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间
  时间复杂度是O(n^2),空间的复杂度是O(1)
  稳定排序: 如果两个元素的位置相同，他们的位置是不会进行交换的"/>

    <meta property="og:title" content="常见的排序算法总结" />
<meta property="og:description" content="经典排序算法的总结   之前总是听一些大牛说学会了排序就相等于学会了算法，能手写个快速排序基本就能通过面试了，这一
 点我是很不理解的；后来慢慢地发现这是有道理的，常见的几种排序算法中蕴含了许多经典的算法思想，
比如说递归、分治、迭代、双指针、空间换时间等，算法的问题很多，但是计算机处理问题的方式却只
有那一种。所以要归根溯源，从简单的排序算法中去学习算法思想也是一种很有效的方法
一、算法描述  对一个无序的数组进行排序 (从小到大或者从大到小)
 二、算法分类标准  划分排序算法的主要标准有稳定性、内外排序、时空复杂度、是否比较排序等
  1.稳定性   如果数组中有两个元素是相等的，在经过某个排序算法之后，原来前面的那个元素仍然在另一个元素的
 前面，那这个排序算法就是稳定的；相反如果在原来两个相等元素中前面的一个元素被移到了后面，那就
是不稳定的
 2.内外排序   内排序是所有的排序操作都在内存中完成；
  外排序是由于数据太大，因此把数据放入磁盘中，排序需要经过磁盘和内存的数据传输才能进行
  3.是否比较排序   比较排序： 一个算法在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个算法
 就是比较排序，常见的排序算法都是比较排序算法，比如冒泡排序、插入排序、堆排序，这些排序
算法的平均时间复杂度最快也只能是O(nlogn)
 非比较排序比较典型的算法有计数排序、桶排序和基数排序，这类排序的时间复杂度可以达到
 O(n)的级别
 4.时空复杂度   就是时间复杂度和空间的复杂度了
 三、常见的排序算法  1.冒泡排序(Bubble Sort)  （1）算法描述：冒泡排序是将相邻元素进行比较,大数慢慢地沉底，小数放置到前面
（2）算法特点：
  内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间
  时间复杂度是O(n^2),空间的复杂度是O(1)
  稳定排序: 如果两个元素的位置相同，他们的位置是不会进行交换的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qmr0925.github.io/datastructure/sort/" />
<meta property="article:published_time" content="2020-04-04T23:04:00+08:00" />
<meta property="article:modified_time" content="2020-04-04T23:04:00+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://qmr0925.github.io"><img class="app-header-avatar" src="/1.png" alt="John Doe" /></a>
      <h1>Your title</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/gohugoio" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="mailto:csuyzz@foxmail.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail">
  <title>mail</title>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>
</svg></a>
        
          <a target="_blank" href="https://cn.linkedin.com/in/csuyzz" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>linkedin</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/gohugoio" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
      <h3><a href="/" title="首页">首页</a></h3>
      <h3><a href="/category/content/" title="首页">分类目录</a></h3>
      <h3><a href="/personal/introduce/" title="首页">个人简介</a></h3>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">常见的排序算法总结</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 4, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          8 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://qmr0925.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
              <a class="tag" href="https://qmr0925.github.io/tags/leetcode/">leetcode</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="经典排序算法的总结">经典排序算法的总结</h2>
<hr>
<blockquote>
<p>之前总是听一些大牛说学会了排序就相等于学会了算法，能手写个快速排序基本就能通过面试了，这一</p>
</blockquote>
<p>点我是很不理解的；后来慢慢地发现这是有道理的，常见的几种排序算法中蕴含了许多经典的算法思想，</p>
<p>比如说递归、分治、迭代、双指针、空间换时间等，算法的问题很多，但是计算机处理问题的方式却只</p>
<p>有那一种。所以要归根溯源，从简单的排序算法中去学习算法思想也是一种很有效的方法</p>
<h3 id="一算法描述">一、算法描述</h3>
<blockquote>
<p>对一个无序的数组进行排序 (从小到大或者从大到小)</p>
</blockquote>
<h3 id="二算法分类标准">二、算法分类标准</h3>
<blockquote>
<p>划分排序算法的主要标准有稳定性、内外排序、时空复杂度、是否比较排序等</p>
</blockquote>
<blockquote>
<h4 id="1稳定性">1.稳定性</h4>
</blockquote>
<blockquote>
<p>如果数组中有两个元素是相等的，在经过某个排序算法之后，原来前面的那个元素仍然在另一个元素的</p>
</blockquote>
<p>前面，那这个排序算法就是稳定的；相反如果在原来两个相等元素中前面的一个元素被移到了后面，那就</p>
<p>是不稳定的</p>
<blockquote>
<h4 id="2内外排序">2.内外排序</h4>
</blockquote>
<blockquote>
<p>内排序是所有的排序操作都在内存中完成；</p>
</blockquote>
<blockquote>
<p>外排序是由于数据太大，因此把数据放入磁盘中，排序需要经过磁盘和内存的数据传输才能进行</p>
</blockquote>
<blockquote>
<h4 id="3是否比较排序">3.是否比较排序</h4>
</blockquote>
<blockquote>
<p>比较排序： 一个算法在排序的过程中使用比较操作来判断两个元素的大小关系，那么这个算法</p>
</blockquote>
<p>就是比较排序，常见的排序算法都是比较排序算法，比如冒泡排序、插入排序、堆排序，这些排序</p>
<p>算法的平均时间复杂度最快也只能是O(nlogn)</p>
<blockquote>
<p>非比较排序比较典型的算法有计数排序、桶排序和基数排序，这类排序的时间复杂度可以达到</p>
</blockquote>
<p>O(n)的级别</p>
<blockquote>
<h4 id="4时空复杂度">4.时空复杂度</h4>
</blockquote>
<blockquote>
<p>就是时间复杂度和空间的复杂度了</p>
</blockquote>
<h3 id="三常见的排序算法">三、常见的排序算法</h3>
<blockquote>
<h4 id="1冒泡排序bubble-sort">1.冒泡排序(Bubble Sort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong>：冒泡排序是将相邻元素进行比较,大数慢慢地沉底，小数放置到前面</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>时间复杂度是O(n^2),空间的复杂度是O(1)</p>
</li>
<li>
<p>稳定排序: 如果两个元素的位置相同，他们的位置是不会进行交换的</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#冒泡排序 Python的版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bubble_sort</span>(nums):
	n <span style="color:#f92672">=</span> len(nums)
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,n<span style="color:#f92672">-</span>i):
			<span style="color:#66d9ef">if</span> nums[j] <span style="color:#f92672">&lt;</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
				nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],nums[j] <span style="color:#f92672">=</span> nums[j],nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
	<span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//冒泡排序  Java版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubbleSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>i<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>j<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>j<span style="color:#f92672">,</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//交换最大值
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="2选择排序select-sort">2.选择排序(Select Sort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>选择排序的思路是先找到前n个元素中最大的值，然后和最后一个元素进行交换，以此来保证最后一个</p>
</blockquote>
<p>元素一定是最大的；然后找到前n-1个元素中的最大值，和第n-1个元素进行比较，依次类推找到前两个元</p>
<p>素中最大的元素和第二个元素进行交换；最后就得到了排序数组</p>
<blockquote>
<p>和冒泡排序的思路相似，都是要把最大的元素放到最后，但是冒泡排序在每一轮比较中交换多次</p>
</blockquote>
<p>而选择排序只需要在每一轮交换依次</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需占用额外的磁盘空间</p>
</li>
<li>
<p>时间复杂度是O(n^2),空间的复杂度是O(1)，原地算法</p>
</li>
<li>
<p>是否稳定排序取决于使用数组还是链表存储数据，使用数组是不稳定的，但是链表是稳定的</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#选择排序 Python的版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">selectSort</span>(nums):
    n <span style="color:#f92672">=</span> len(nums)
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,n):
        maxIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>,n<span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> nums[maxIndex] <span style="color:#f92672">&lt;</span> nums[j]:
                maxIndex <span style="color:#f92672">=</span> j
        <span style="color:#75715e">#将最大的元素和最后一个元素进行交换</span>
	    nums[maxIndex],nums[n<span style="color:#f92672">-</span>i] <span style="color:#f92672">=</span> nums[n<span style="color:#f92672">-</span>i],nums[maxIndex]
	<span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//选择排序  Java版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>i <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">;</span>i<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> maxIndex <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>   <span style="color:#75715e">//每轮循环开始都要记录一个最大元素的位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>j<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>maxIndex<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                maxIndex <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>maxIndex<span style="color:#f92672">,</span>i<span style="color:#f92672">)</span><span style="color:#f92672">;</span>   <span style="color:#75715e">//把这个最大的元素移到最后
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="3插入排序insertsort">3.插入排序(InsertSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>插入排序的思想是遍历整个数组，保持当前元素的左侧始终是排序后的数组，然后将当前元素插入到</p>
</blockquote>
<p>前面排序完成的数组的对应的位置，使其保持排序的状态，类似于动态规划，先将前i - 1个元素排序完成</p>
<p>再去插入第i个元素，构成i个元素的有序数组</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>时间复杂度：如果是已经排序的数组，复杂度就是O(n)，在其他情况下都是O(n^2)</p>
</li>
<li>
<p>稳定排序: 插入排序是相邻元素之间的交换，而不是跳跃式的交换，所以是稳定的</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#冒泡排序 Python的版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert_sort</span>(nums):
	n <span style="color:#f92672">=</span> len(nums)
	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>,n):   <span style="color:#75715e">#要从第二个元素开始遍历</span>
        j <span style="color:#f92672">=</span> i
	    <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums[j] <span style="color:#f92672">&lt;</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
            nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],nums[j] <span style="color:#f92672">=</span> nums[j],nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
		   j<span style="color:#f92672">-</span><span style="color:#f92672">-</span>	
	<span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//插入排序  Java版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>  <span style="color:#75715e">//默认第一个元素是排好序的，从第二个元素开始排
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>j<span style="color:#f92672">,</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            j<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="4希尔排序shellsort">4.希尔排序(ShellSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>希尔排序可以看作是冒泡排序或者插入排序的升级，这种排序算法在每次排序的时候都把数组拆分</p>
</blockquote>
<p>成若干个序列，一个序列的相邻元素的索引间隔为固定的距离，每一轮对这些序列进行冒泡或者插入，</p>
<p>然后在缩小索引间隔得到新的序列，直到间隔为0</p>
<p><strong>（2）算法特点</strong></p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>时间复杂度：不同的增量序列会有不同的时间复杂度，一般介于O(n^1.5)到 O(n^2)，空间复杂度是O(1)</p>
</li>
<li>
<p>稳定性: 这个算法是不稳定的，里面有很多不相邻元素的交换操作</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#希尔排序 Python的版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shell_sort</span>(nums):
	n <span style="color:#f92672">=</span> len(nums)
    gap <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span><span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
	<span style="color:#66d9ef">while</span> gap:
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(gap,n):
            <span style="color:#66d9ef">while</span> i <span style="color:#f92672">-</span> gap <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nums[i<span style="color:#f92672">-</span>gap] <span style="color:#f92672">&gt;</span> nums[i]:   <span style="color:#75715e">#插入排序</span>
                nums[i<span style="color:#f92672">-</span>gap],nums[i] <span style="color:#f92672">=</span> nums[i],nums[i<span style="color:#f92672">-</span>gap]
                i <span style="color:#f92672">-</span><span style="color:#f92672">=</span> gap
        gap <span style="color:#f92672">&gt;&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//希尔排序  Java版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shellSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> gap <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>gap <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> gap<span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//对每个子序列进行排序
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>gap<span style="color:#f92672">;</span>j <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>j<span style="color:#f92672">+</span><span style="color:#f92672">=</span>gap<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//插入排序
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>temp <span style="color:#f92672">&gt;</span> i <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums<span style="color:#f92672">[</span>temp<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>temp <span style="color:#f92672">-</span> gap<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                    swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>temp<span style="color:#f92672">,</span>temp<span style="color:#f92672">-</span>gap<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
                    temp <span style="color:#f92672">-</span><span style="color:#f92672">=</span> gap<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        gap <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="5快速排序quicksort">5.快速排序(QuickSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>快速排序的核心思想就是取一个元素(可以是第一个或者最后一个)作为分界点，将整个数组分成左右</p>
</blockquote>
<p>两侧，左边的元素小于或者等于分界点元素，而右边的元素大于分界点的元素；再对左右子数组进行递归</p>
<p>即可，当子数组只有一个元素或者没有元素的时候就结束这个递归的过程</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>复杂度分析：时间复杂度最佳是O(nlogn)，但是如果分界点元素选择不正确会恶化到O(n^2)，这种情况是</p>
<blockquote>
<p>数组完全逆序时的表现。如果随机选择分界点时间复杂度能够稳定在O(nlogn)。此外，如果相同元素</p>
</blockquote>
<blockquote>
<p>数量比较多的情况下，也会降低排序的性能；空间复杂度为O(logn)，属于堆栈调用，最坏情况下的</p>
</blockquote>
<blockquote>
<p>空间复杂度还是O(n)，只有平均情况是O(nlogn)</p>
</blockquote>
</li>
<li>
<p>稳定性: 是不稳定的排序，因为包含跳跃式的交换元素</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#快速排序 Python的版本 (写法一) </span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quick_sort</span>(data):
	<span style="color:#66d9ef">if</span> len(data) <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>:
		mid <span style="color:#f92672">=</span> data[len(data) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]  <span style="color:#75715e">#选取一个基准值，这里选取的是最后一个元素</span>
		left,right <span style="color:#f92672">=</span> [],[]   <span style="color:#75715e">#定义基准值左右两侧的列表</span>
		data<span style="color:#f92672">.</span>remove(mid)     <span style="color:#75715e">#先从原数组中将当前元素移除</span>
		<span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> data:
			<span style="color:#66d9ef">if</span> num <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> mid:
				right<span style="color:#f92672">.</span>append(num)   <span style="color:#75715e">#大于基准值的放在右边</span>
			<span style="color:#66d9ef">else</span>:
				left<span style="color:#f92672">.</span>append(num)    <span style="color:#75715e">#小于基准值的放在左边</span>
		<span style="color:#66d9ef">return</span> quick_sort(left) <span style="color:#f92672">+</span> [mid] <span style="color:#f92672">+</span> quick_sort(right)
	<span style="color:#66d9ef">else</span>:
		<span style="color:#66d9ef">return</span> data           <span style="color:#75715e">#如果只有一个元素时直接返回</span>
<span style="color:#75715e">#毫无疑问这种写法很简洁，但是非常地浪费空间</span>

<span style="color:#75715e">#快速排序 Python的版本 (写法二) 在原数组中操作</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quick_sort</span>(nums):
    n <span style="color:#f92672">=</span> len(nums)
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">quick</span>(left,right):
        <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> right:
            <span style="color:#66d9ef">return</span> nums
        pivot <span style="color:#f92672">=</span> left
        i <span style="color:#f92672">=</span> left
        j <span style="color:#f92672">=</span> right
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> j:
 			<span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">and</span> nums[j] <span style="color:#f92672">&gt;</span> nums[pivot]:
                j <span style="color:#f92672">-</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
             <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> j <span style="color:#f92672">and</span> nums[i] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> nums[pivot]:
                i <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
             nums[i],nums[j] <span style="color:#f92672">=</span> nums[j],nums[i]
        nums[pivot],nums[j] <span style="color:#f92672">=</span> nums[j],nums[pivot]
        quick(left,j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        quick(j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,right)
        <span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//快速排序  Java版本 (写法一)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>   <span style="color:#75715e">//小于分界点元素最右侧的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hi <span style="color:#f92672">=</span> right<span style="color:#f92672">;</span>      <span style="color:#75715e">//大于分界点元素最左侧的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> hi<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>lo<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> nums<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>  <span style="color:#75715e">//左侧指针指向的元素小于分界点元素
</span><span style="color:#75715e"></span>            swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>lo<span style="color:#f92672">,</span>hi<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            hi<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            lo<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> 
    <span style="color:#f92672">}</span>
    lo<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//回到小于分界点元素的最右侧
</span><span style="color:#75715e"></span>    swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>left<span style="color:#f92672">,</span>lo<span style="color:#f92672">)</span><span style="color:#f92672">;</span>  <span style="color:#75715e">//将分界点元素移到左侧数组的最右侧
</span><span style="color:#75715e"></span>    QuickSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>left<span style="color:#f92672">,</span>lo<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    QuickSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>lo<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>right<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">//快速排序  Java版本 (写法二)
</span><span style="color:#75715e"></span><span style="color:#75715e">/*不用hi来标记分界点元素的最右侧,而是只有一个lo来标记最左侧
</span><span style="color:#75715e">在遍历整个数组的过程中，如果发现了一个小于等于分界点元素的元素，就和lo+1位置的元素进行交换
</span><span style="color:#75715e">然后lo自增,这样可以保证lo左侧一定都是小于等于分界点元素的，遍历到最后lo的位置就是新的分界点的位置
</span><span style="color:#75715e">和最开始的分界点元素位置互换
</span><span style="color:#75715e">*/</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>    <span style="color:#75715e">//从左侧第二个元素 开始
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> left<span style="color:#f92672">;</span>         <span style="color:#75715e">//最左侧的元素作为基准值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>cur <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>cur<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//交换位置保证lo的左侧都是小于nums[left]的
</span><span style="color:#75715e"></span>            swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>lo<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>cur<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            lo<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>left<span style="color:#f92672">,</span>lo<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    QuickSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>left<span style="color:#f92672">,</span>lo<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    QuickSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>lo<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>right<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="6归并排序quicksort">6.归并排序(QuickSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>归并排序的核心思想就是分治法，先将数组分成子序列，再让子序列间有序，合并成有序数组</p>
</blockquote>
<blockquote>
<p>主要的步骤如下：</p>
</blockquote>
<ul>
<li>
<p>将长度为n的输入序列分成长度为n/2的子序列</p>
</li>
<li>
<p>对两个子序列进行归并排序</p>
</li>
<li>
<p>合并所有的子序列</p>
</li>
</ul>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>复杂度分析：每个元素都要经过logn次的排序，所以时间复杂度是O(nlogn)；排序的过程中要使用临</p>
<blockquote>
<p>时数组来存放临时排序结果，空间复杂度为O(n)</p>
</blockquote>
</li>
<li>
<p>稳定性: 稳定排序，保证原来相同的元素能够在相同的位置</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#归并排序  Python版本  实现</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MergeSort</span>(lists):
    <span style="color:#66d9ef">if</span> len(lists) <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>:
        num <span style="color:#f92672">=</span> len(lists)<span style="color:#f92672">/</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>
        left <span style="color:#f92672">=</span> MergeSort(lists[:num])
        right <span style="color:#f92672">=</span> MergeSort(lists[num:])
        <span style="color:#66d9ef">return</span> Merge(left,right)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">Merge</span>(left,right):
    r,l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>
    result <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;</span> len(left) <span style="color:#f92672">and</span> r <span style="color:#f92672">&lt;</span> len(right):
		<span style="color:#66d9ef">if</span> left[l] <span style="color:#f92672">&lt;</span> right[r]:
			result<span style="color:#f92672">.</span>append(left[l])
			l<span style="color:#f92672">+</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
		<span style="color:#66d9ef">else</span>:
			result<span style="color:#f92672">.</span>append(right[r])
			r<span style="color:#f92672">+</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
	result<span style="color:#f92672">+</span><span style="color:#f92672">=</span>list(left[l:])
	result<span style="color:#f92672">+</span><span style="color:#f92672">=</span>list(right[r:])
	<span style="color:#66d9ef">return</span> result
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//归并排序  Java版本  具体实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergeSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>left<span style="color:#f92672">+</span>right<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
    
    mergeSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>left<span style="color:#f92672">,</span>mid<span style="color:#f92672">)</span><span style="color:#f92672">;</span>     <span style="color:#75715e">//先对左右子数组进行排序
</span><span style="color:#75715e"></span>    mergeSort<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>mid<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>right<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> temp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>right<span style="color:#f92672">-</span>left<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span><span style="color:#f92672">;</span>               <span style="color:#75715e">//临时数组存放合并的结果
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> left<span style="color:#f92672">,</span>j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> mid <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span><span style="color:#f92672">)</span> temp<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> temp<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> mid<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        temp<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> right<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        temp<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#75715e">//合并数组完成，拷贝到原来的数组  左边界是从left开始排序的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>k <span style="color:#f92672">&lt;</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>k<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        nums<span style="color:#f92672">[</span>left<span style="color:#f92672">+</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="7堆排序heapsort">7.堆排序(HeapSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>首先把整个数组变成一个大顶堆，然后每次从堆顶取出最大的元素。这样依次取出的最大元素就形成</p>
</blockquote>
<p>了一个排序的数组；堆排序的主要操作就是新建堆和调整堆</p>
<blockquote>
<p>堆的底层数据结构数组，实际上堆可以看成一个完全二叉树，除了最后一层之外其他的每一层都被</p>
</blockquote>
<p>完全填充了；对于下标为 i 的元素，它的子节点是2 * i + 1，2 * i + 2(不能超出边界)，这样就可以明确</p>
<p>父节点和子节点之间的关系了</p>
<blockquote>
<p>在新建堆的时候从左向右开始遍历，当遍历到一个元素的时候，重新排列从这个元素节点到根节点的</p>
</blockquote>
<p>所有元素，保证满足最大堆的要求；遍历完成，堆也就建好了</p>
<blockquote>
<p>在弹出根节点后，将树的最底层最右侧的元素转移到堆顶来，此时堆被破坏，需要重建。从根节点</p>
</blockquote>
<p>开始和两个子节点比较，如果父节点比所有的子节点小，需要互换父节点和最大的子节点，然后把互换</p>
<p>后在子节点的位置当作新的父节点，和它的子节点比较，如此往复直到最后一层，重建完成</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>内排序，所有操作在原来的数组中就可以完成了，不需要额外的空间</p>
</li>
<li>
<p>复杂度分析：时间复杂度稳定在O(nlogn)，因为在构建堆的时候对于每个元素需要进行O(logn)次比较</p>
</li>
</ul>
<blockquote>
<p>时间复杂度是O(nlogn)；弹出每个元素重建堆也是需要调整O(logn)次，时间复杂度是O(nlogn)</p>
</blockquote>
<blockquote>
<p>所以整体的时间复杂度是O(nlogn) 。 空间复杂度是O(1)，在原数组内进行所有操作即可</p>
</blockquote>
<ul>
<li>
<p>稳定性: 不稳定的排序，新建堆和调整堆的过程都会打乱元素的相对位置</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#堆排序 Python版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">heap_sort</span>(nums):
    <span style="color:#75715e">#调整堆</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">adjust_heap</span>(nums,startpos,endpos):
        pos <span style="color:#f92672">=</span> startpos              <span style="color:#75715e">#父节点</span>
        maxchildpos <span style="color:#f92672">=</span> pos <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>   <span style="color:#75715e">#最大子节点,初始化成左子节点</span>
        <span style="color:#66d9ef">if</span> maxchildpos <span style="color:#f92672">&lt;</span> endpos:
            rightpos <span style="color:#f92672">=</span> maxchildpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> rightpos <span style="color:#f92672">&lt;</span> endpos <span style="color:#f92672">and</span> nums[rightpos] <span style="color:#f92672">&gt;</span> nums[childpos]:
                maxchildpos <span style="color:#f92672">=</span> rightpos   <span style="color:#75715e">#右子节点比左子节点大</span>
            <span style="color:#66d9ef">if</span> nums[maxchildpos] <span style="color:#f92672">&gt;</span> nums[pos]:
                nums[pos],nums[maxchildpos] <span style="color:#f92672">=</span> nums[maxchildpos],nums[pos]
            	adjust_heap(nums,pos,endpos)
 
    n <span style="color:#f92672">=</span> len(nums)
    <span style="color:#75715e">#建堆</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(n<span style="color:#f92672">/</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)):
        adjust_heap(nums,i,n)
    <span style="color:#75715e">#调整堆</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
        nums[<span style="color:#ae81ff">0</span>],nums[i] <span style="color:#f92672">=</span> nums[i],nums[<span style="color:#ae81ff">0</span>]
        adjust_heap(nums,<span style="color:#ae81ff">0</span>,i)
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//堆排序  Java版本  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    heapify<span style="color:#f92672">(</span>nums<span style="color:#f92672">)</span><span style="color:#f92672">;</span>        <span style="color:#75715e">//新建一个大顶堆
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>i <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>i<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>i<span style="color:#f92672">)</span><span style="color:#f92672">;</span>   <span style="color:#75715e">//弹出最大的堆顶放在最后  因为要从小到大地进行排序
</span><span style="color:#75715e"></span>        rebuildHeap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>i<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>  <span style="color:#75715e">//重新调整最大堆
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">//将一个数组堆化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> par <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>1<span style="color:#f92672">;</span>    <span style="color:#75715e">//找到父节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> child <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>         <span style="color:#75715e">//定义子节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>child <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums<span style="color:#f92672">[</span>par<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>child<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>  <span style="color:#75715e">//从子节点到父节点构建最大堆
</span><span style="color:#75715e"></span>            swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>par<span style="color:#f92672">,</span>child<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            child <span style="color:#f92672">=</span> par<span style="color:#f92672">;</span>
            par <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>par<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> 1<span style="color:#f92672">;</span>    <span style="color:#75715e">//把父节点当成子节点去寻找新的父节点
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">//重建堆
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rebuildHeap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> par<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> last<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> 2<span style="color:#f92672">*</span>par <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>   <span style="color:#75715e">//左子节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> 2<span style="color:#f92672">*</span>par <span style="color:#f92672">+</span> 2<span style="color:#f92672">;</span>  <span style="color:#75715e">//右子节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxIndex <span style="color:#f92672">=</span> left<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>right <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> last <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums<span style="color:#f92672">[</span>right<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> nums<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        maxIndex <span style="color:#f92672">=</span> right<span style="color:#f92672">;</span>             <span style="color:#75715e">//maxIndex是最大子节点下标的索引
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> last <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> nums<span style="color:#f92672">[</span>par<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">[</span>maxIndex<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span> <span style="color:#75715e">//和最大的子节点进行比较
</span><span style="color:#75715e"></span>        swap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>par<span style="color:#f92672">,</span>maxIndex<span style="color:#f92672">)</span><span style="color:#f92672">;</span>                    <span style="color:#75715e">//互换到最大子节点
</span><span style="color:#75715e"></span>        rebuildHeap<span style="color:#f92672">(</span>nums<span style="color:#f92672">,</span>maxIndex<span style="color:#f92672">,</span>last<span style="color:#f92672">)</span><span style="color:#f92672">;</span>            <span style="color:#75715e">//重建最大子节点代表的子树
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="8计数排序countingsort">8.计数排序(CountingSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>计数排序是典型的空间换时间的算法，开辟额外数据空间存储元素索引和元素值出现的个数</p>
</blockquote>
<blockquote>
<p>具体的过程如下：</p>
</blockquote>
<ul>
<li>
<p>创建一个长度为数组中最小和最大元素之差的数组，分别对应数组中的每个元素</p>
</li>
<li>
<p>使用新创建的数组来统计每个元素出现的频率，然后遍历新的数组，根据每个元素出现的频率</p>
</li>
</ul>
<blockquote>
<p>将元素放回到老的数组中，得到已经排序好的数组</p>
</blockquote>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>外排序，对于数据范围很大的数组，需要大量的时间和内存</p>
</li>
<li>
<p>复杂度分析：时间复杂度为O(n + r) 其中r为数组元素变化的范围，随着数组范围的变大，计数排序</p>
<blockquote>
<p>的性能逐渐地在降低；空间复杂度为O(n + r)，随着数组元素范围的增大，空间复杂度也会</p>
</blockquote>
<blockquote>
<p>增大</p>
</blockquote>
</li>
<li>
<p>稳定性: 计数排序是稳定的，原先排在前面的元素仍然是排在前面</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#计数排序  Python版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">counting_sort</span>(nums):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums: <span style="color:#66d9ef">return</span> []
    n <span style="color:#f92672">=</span> len(nums)
    minValue <span style="color:#f92672">=</span> min(nums)
    maxValue <span style="color:#f92672">=</span> max(nums)
    tempArr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (maxValue <span style="color:#f92672">-</span> minValue <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
    
    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
        tempArr[num <span style="color:#f92672">-</span> minValue] <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
        <span style="color:#66d9ef">while</span> tempArr[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            j <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        nums[i] <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> minValue
        tempArr[j] <span style="color:#f92672">-</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
     <span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//计数排序 Java版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">countSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>           <span style="color:#75715e">//找到最大值和最小值
</span><span style="color:#75715e"></span>        min <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>min<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>max<span style="color:#f92672">-</span>min<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span><span style="color:#f92672">;</span>  <span style="color:#75715e">//建立新数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>               <span style="color:#75715e">//统计每个元素出现的次数
</span><span style="color:#75715e"></span>        count<span style="color:#f92672">[</span>num<span style="color:#f92672">-</span>min<span style="color:#f92672">]</span><span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>              <span style="color:#75715e">//用来表示原数组的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> count<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//根据出现的频率将数组中的元素放回到旧数组中
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>count<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            nums<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> min<span style="color:#f92672">;</span>
            count<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">;</span>s
        <span style="color:#f92672">}</span>   
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="9基数排序countingsort">9.基数排序(CountingSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>基数排序的思想就是对数字中的每一位进行排序，从最低位开始</p>
</blockquote>
<blockquote>
<p>具体的过程如下：</p>
</blockquote>
<ul>
<li>
<p>找到数组中的最大值，先得到最大的位数</p>
</li>
<li>
<p>从最低位开始去每个位组成radix数组</p>
</li>
<li>
<p>对radix进行计数排序(计数排序比较适合小范围内的排序)</p>
</li>
</ul>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>外排序，因为需要使用辅助的数组来临时存储元素</p>
</li>
<li>
<p>复杂度分析：时间复杂度为O(k*n)，其中k为绝对值最大元素的位数；空间复杂度也是线性的</p>
</li>
<li>
<p>稳定性: 基数排序是稳定的，在排序添加元素的过程中没有改变相同元素的位置关系</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#基数排序  Python版本</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">Radix_sort</span>(nums):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums: <span style="color:#66d9ef">return</span> []
    maxValue <span style="color:#f92672">=</span> max(nums)   <span style="color:#75715e">#找到最大值</span>
    maxDigit <span style="color:#f92672">=</span> len(str(maxValue))  <span style="color:#75715e">#最大的位数</span>
    bucketList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>)]   <span style="color:#75715e">#存放每一位相同的元素列表 二维列表</span>
    
    <span style="color:#75715e">#要从最低位开始排序</span>
    div,mod <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">10</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(maxDigit):
        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
            bucketList[num <span style="color:#f92672">%</span> mod <span style="color:#f92672">/</span><span style="color:#f92672">/</span> div]<span style="color:#f92672">.</span>append(num)
        div <span style="color:#f92672">*</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>        
        mod <span style="color:#f92672">*</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
        
        idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>       <span style="color:#75715e">#原来数组下标的索引</span>
        <span style="color:#75715e">#每一轮排序完将桶内的元素放回原数组中</span>
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):                 <span style="color:#75715e">#每位数字只能是0-9,总共有10个</span>
            <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> bucketList[j]:      
                nums[idx] <span style="color:#f92672">=</span> item
                idx <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            bucketList[j] <span style="color:#f92672">=</span> []              <span style="color:#75715e">#将桶内的元素取出后,清空该桶</span>
    <span style="color:#66d9ef">return</span> nums
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//基数排序 Java版本
</span><span style="color:#75715e"></span><span style="color:#75715e">//考虑到数组中还有负数的情况 可以把桶的大小扩大到19个  -9 - 9
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Radix_Sort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//计算最大值和最小值
</span><span style="color:#75715e"></span>         max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
         min <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>min<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span><span style="color:#f92672">-</span>min<span style="color:#f92672">)</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//求得绝对值的最大值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> digits <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>max <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span><span style="color:#f92672">{</span>              <span style="color:#75715e">//计算最大值的位数               
</span><span style="color:#75715e"></span>        max <span style="color:#f92672">/</span><span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
        digits<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> buckets <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> List<span style="color:#f92672">[</span>19<span style="color:#f92672">]</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//创建一个包含一个所有位数的数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        buckets<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>       <span style="color:#75715e">//实际上相当于是二维列表
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">int</span> pos<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cur<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>mod <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> digits<span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">,</span>mod <span style="color:#f92672">*</span><span style="color:#f92672">=</span> 10<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//对10进制的每一位进行基数排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>              <span style="color:#75715e">//扫描数组将值放入对应的桶中
</span><span style="color:#75715e"></span>            pos <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>num <span style="color:#f92672">/</span> mod<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> 10<span style="color:#f92672">;</span>       <span style="color:#75715e">// -9对应的索引为0
</span><span style="color:#75715e"></span>            buckets<span style="color:#f92672">[</span>pos<span style="color:#f92672">+</span>9<span style="color:#f92672">]</span><span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        cur <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>   <span style="color:#75715e">//指向原数组的索引
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> bucket <span style="color:#f92672">:</span> buckets<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//将桶内的元素放回到原来的数组中
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>bucket <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>Integer item <span style="color:#f92672">:</span> bucket<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                    nums<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> item<span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                bucket<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>                <span style="color:#75715e">//将桶清空,已备下次使用
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>   
        <span style="color:#f92672">}</span> 
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="10桶排序bucketsort">10.桶排序(BucketSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>桶排序就是将所有的元素分布到一系列的桶中，然后对每个桶里面的所有元素分别进行排序</p>
</blockquote>
<blockquote>
<p>具体的过程如下：</p>
</blockquote>
<ul>
<li>
<p>新建一个桶的数组，提前制定好桶的规则，比如元素0-9在一个桶，10-19为一个桶</p>
</li>
<li>
<p>遍历待排序的数组，将元素分别分配到对应的桶中</p>
</li>
<li>
<p>对每个桶中的元素进行排序</p>
</li>
<li>
<p>最后将所有的桶中的元素还原到原数组中得到最后的排序数组</p>
</li>
</ul>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>外排序，因为需要使用辅助的数组来临时存储元素</p>
</li>
<li>
<p>复杂度分析：时间复杂度是O(n+r)，随着元素范围的扩大，时间的消耗也在不断增大，其中r为数组元素变</p>
</li>
</ul>
<blockquote>
<p>化的范围；空间复杂度也是O(n+r)，需要额外的空间来保存所有的桶和桶中的元素</p>
</blockquote>
<ul>
<li>
<p>稳定性: 桶排序是稳定的，与计数排序是类似的</p>
<p><strong>（3）代码实现</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bucketSort</span>(nums,bucketSize):
    <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:   <span style="color:#75715e">#递归终止的条件</span>
        <span style="color:#66d9ef">return</span> nums
    minValue <span style="color:#f92672">=</span> min(nums)
    maxValue <span style="color:#f92672">=</span> max(nums)
      
    <span style="color:#75715e">#需要的桶个数</span>
    bucketNum <span style="color:#f92672">=</span> (maxValue <span style="color:#f92672">-</span> minValue)<span style="color:#f92672">/</span><span style="color:#f92672">/</span>bucketSize <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;   <span style="color:#75715e">#向下取整的 要加1</span>
    buckets <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(bucketNum)]
      
    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
        <span style="color:#75715e">#放入对应的桶中</span>
        buckets[(num <span style="color:#f92672">-</span> minValue) <span style="color:#f92672">/</span><span style="color:#f92672">/</span> bucketSize]<span style="color:#f92672">.</span>append(num)
    res <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> bucket <span style="color:#f92672">in</span> buckets:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> bucket: <span style="color:#66d9ef">continue</span>
        <span style="color:#66d9ef">if</span> bucketSize <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            res<span style="color:#f92672">.</span>extend(bucket)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#75715e">#都装在一个桶里</span>
            <span style="color:#66d9ef">if</span> bucketNum <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                bucketSize <span style="color:#f92672">-</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            res<span style="color:#f92672">.</span>extend(bucketSort(bucket,bucketSize))
    <span style="color:#66d9ef">return</span> res
</code></pre></div></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bucketSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> INTERVAL <span style="color:#f92672">=</span> 100<span style="color:#f92672">;</span>     <span style="color:#75715e">//定义桶的大小
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//找出最大值和最小值
</span><span style="color:#75715e"></span>        min <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>min<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>max<span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>max <span style="color:#f92672">-</span> min <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//数据范围
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> bucketSize <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>count <span style="color:#f92672">%</span> INTERVAL <span style="color:#f92672">=</span><span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span><span style="color:#f92672">?</span> <span style="color:#f92672">(</span>count <span style="color:#f92672">/</span> INTERVAL<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>count <span style="color:#f92672">/</span> INTERVAL <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    
    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> buckets <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> List<span style="color:#f92672">[</span>bucketSize<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">:</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>   <span style="color:#75715e">//将所有的元素都放入对应的桶里面
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>num <span style="color:#f92672">-</span> min<span style="color:#f92672">)</span><span style="color:#f92672">/</span>INTERVAL<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>buckets<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> buckets<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        buckets<span style="color:#f92672">[</span>pos<span style="color:#f92672">]</span><span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> bucket<span style="color:#f92672">:</span>buckets<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>bucket <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            bucket<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>     <span style="color:#75715e">//对每个桶进行排序
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>Integer item <span style="color:#f92672">:</span> bucket<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
                nums<span style="color:#f92672">[</span>cur<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> item<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<h4 id="11二叉搜索树排序binary-treesort">11.二叉搜索树排序(Binary-TreeSort)</h4>
</blockquote>
<p><strong>（1）算法描述</strong></p>
<blockquote>
<p>二叉搜索树排序使用数组中内的所有元素构建一颗二叉搜索树，然后用中序遍历将所有的元素填充</p>
</blockquote>
<p>回原来的数组中。搜索二叉树不能用数组表示，所以必须使用额外的数据结构来构建二叉树</p>
<p><strong>（2）算法特点</strong>：</p>
<ul>
<li>
<p>外排序，因为需要使用辅助的数组来临时存储元素</p>
</li>
<li>
<p>复杂度分析：最差情况下整个数组是排好序的，时间复杂度是O(n^2)，二叉树会变成一个链表结构；但是</p>
</li>
</ul>
<blockquote>
<p>在最优和平均情况下时间复杂度在O(nlogn)的水平；空间复杂度为O(n)，因为要构建一个包含n个</p>
</blockquote>
<blockquote>
<p>元素的二叉搜索树</p>
</blockquote>
<ul>
<li>
<p>稳定性: 这个排序是稳定的，构建二叉树的过程中能够保证元素的一致性</p>
<p><strong>（3）代码实现</strong></p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> val<span style="color:#f92672">;</span>        <span style="color:#75715e">//树节点的数据结构
</span><span style="color:#75715e"></span>    TreeNode left<span style="color:#f92672">;</span>
    TreeNode right<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">TreeNode</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> val<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> <span style="color:#a6e22e">BSTSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>nums<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//构建一个根节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;</span> nums<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>       <span style="color:#75715e">//将所有的元素插入到二叉搜索树中
</span><span style="color:#75715e"></span>        buildTree<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span>nums<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    midTraverse<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span>nums<span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>1<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>      <span style="color:#75715e">//中序遍历获取二叉树中的所有节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> nums<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">//中序遍历二叉树
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">midTraverse</span><span style="color:#f92672">(</span>TreeNode node<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> nums<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> pos<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>node <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    midTraverse<span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>nums<span style="color:#f92672">,</span>pos<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    nums<span style="color:#f92672">[</span>pos<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span><span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
    midTraverse<span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span>nums<span style="color:#f92672">,</span>pos<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">//构建一颗二叉搜索树
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildTree</span><span style="color:#f92672">(</span>TreeNode node<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> num<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>node <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>num <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>    <span style="color:#75715e">//大于要插入到右子树
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            buildTree<span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>    <span style="color:#75715e">//小于的话插入到左子树
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            buildTree<span style="color:#f92672">(</span>node<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>num<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>
  <script src="https://utteranc.es/client.js"
        repo="qmr/hugocomments"
        issue-term="pathname"
        theme="github-dark"  
        crossorigin="anonymous"
        async>
</script>

    </main>
  </body>
</html>
